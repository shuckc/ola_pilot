# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: protocol/Ola.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import List, Optional

import betterproto
import grpclib


class RegisterAction(betterproto.Enum):
    REGISTER = 1
    UNREGISTER = 2


class PatchAction(betterproto.Enum):
    PATCH = 1
    UNPATCH = 2


class MergeMode(betterproto.Enum):
    HTP = 1
    LTP = 2


class PluginIds(betterproto.Enum):
    """* Please see the note below about getting a new Plugin ID."""

    OLA_PLUGIN_ALL = 0
    OLA_PLUGIN_DUMMY = 1
    OLA_PLUGIN_ARTNET = 2
    OLA_PLUGIN_SHOWNET = 3
    OLA_PLUGIN_ESPNET = 4
    OLA_PLUGIN_USBPRO = 5
    OLA_PLUGIN_OPENDMX = 6
    OLA_PLUGIN_SANDNET = 7
    OLA_PLUGIN_STAGEPROFI = 8
    OLA_PLUGIN_PATHPORT = 9
    OLA_PLUGIN_DMX4LINUX = 10
    OLA_PLUGIN_E131 = 11
    OLA_PLUGIN_USBDMX = 12
    OLA_PLUGIN_FTDIDMX = 13
    OLA_PLUGIN_OSC = 14
    OLA_PLUGIN_SPI = 15
    OLA_PLUGIN_KINET = 16
    OLA_PLUGIN_KARATE = 17
    OLA_PLUGIN_MILINST = 18
    OLA_PLUGIN_RENARD = 19
    OLA_PLUGIN_UARTDMX = 20
    OLA_PLUGIN_OPENPIXELCONTROL = 21
    OLA_PLUGIN_GPIO = 22
    OLA_PLUGIN_SPIDMX = 23
    OLA_PLUGIN_NANOLEAF = 24


class RDMResponseCode(betterproto.Enum):
    """
    * If you add more here be sure to update ResponseCodeToString in
    RDMHelper.cpp
    """

    # The request/response completed correctly
    RDM_COMPLETED_OK = 0
    # The request was broadcast, no response expected
    RDM_WAS_BROADCAST = 1
    # We failed to send this request
    RDM_FAILED_TO_SEND = 2
    # The response timed out
    RDM_TIMEOUT = 3
    # The response was invalid
    RDM_INVALID_RESPONSE = 4
    # The UID could not be located (may have been removed)
    RDM_UNKNOWN_UID = 5
    # The response checksum was wrong
    RDM_CHECKSUM_INCORRECT = 6
    # Invalid transaction number
    RDM_TRANSACTION_MISMATCH = 7
    # Wrong sub device
    RDM_SUB_DEVICE_MISMATCH = 8
    # Source UID in response doesn't match
    RDM_SRC_UID_MISMATCH = 9
    # Destination UID in response doesn't match
    RDM_DEST_UID_MISMATCH = 10
    # Incorrect sub start code
    RDM_WRONG_SUB_START_CODE = 11
    # RDM response was smaller than the minimum size
    RDM_PACKET_TOO_SHORT = 12
    # The length field of packet didn't match length received
    RDM_PACKET_LENGTH_MISMATCH = 13
    # The parameter length exceeds the remaining packet size
    RDM_PARAM_LENGTH_MISMATCH = 14
    # The command class was not one of GET_RESPONSE or SET_RESPONSE
    RDM_INVALID_COMMAND_CLASS = 15
    # The command class didn't match the request
    RDM_COMMAND_CLASS_MISMATCH = 16
    # The response type was not ACK, ACK_OVERFLOW, ACK_TIMER or NACK
    RDM_INVALID_RESPONSE_TYPE = 17
    # The discovery command class is not supported by this device. This typically
    # means the hardware doesn't support discovery commands.
    RDM_PLUGIN_DISCOVERY_NOT_SUPPORTED = 18
    # Responses to DUB commands, these responses won't have a defined RDM
    # message, but rather just a string of bytes from the wire.
    RDM_DUB_RESPONSE = 19


class RDMResponseType(betterproto.Enum):
    """
    * The valid Response Types when the response_code is RDM_COMPLETED_OK.
    ACK_OVERFLOW isn't in this list because overflows are handed by the
    plugins, not the clients.
    """

    RDM_ACK = 0
    RDM_ACK_TIMER = 1
    RDM_NACK_REASON = 2


class RDMCommandClass(betterproto.Enum):
    """* The RDM command class"""

    RDM_GET_RESPONSE = 0
    RDM_SET_RESPONSE = 1
    RDM_DISCOVERY_RESPONSE = 2


class TimeCodeType(betterproto.Enum):
    TIMECODE_FILM = 0
    TIMECODE_EBU = 1
    TIMECODE_DF = 2
    TIMECODE_SMPTE = 3


@dataclass
class STREAMING_NO_RESPONSE(betterproto.Message):
    """
    This is a special string which indicates that no response will be received
    for an RPC.
    """

    pass


@dataclass
class Ack(betterproto.Message):
    """Generic Ack Message"""

    pass


@dataclass
class PluginListRequest(betterproto.Message):
    """request the list of available plugins"""

    pass


@dataclass
class PluginReloadRequest(betterproto.Message):
    """Trigger a plugin reload."""

    pass


@dataclass
class PluginInfo(betterproto.Message):
    plugin_id: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    active: bool = betterproto.bool_field(3)
    enabled: bool = betterproto.bool_field(4)


@dataclass
class PluginListReply(betterproto.Message):
    plugin: List["PluginInfo"] = betterproto.message_field(1)


@dataclass
class PluginDescriptionRequest(betterproto.Message):
    """request the description for a plugin"""

    plugin_id: int = betterproto.int32_field(1)


@dataclass
class PluginDescriptionReply(betterproto.Message):
    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)


@dataclass
class PluginStateRequest(betterproto.Message):
    """request the state for a plugin"""

    plugin_id: int = betterproto.int32_field(1)


@dataclass
class PluginStateReply(betterproto.Message):
    name: str = betterproto.string_field(1)
    enabled: bool = betterproto.bool_field(2)
    active: bool = betterproto.bool_field(3)
    preferences_source: str = betterproto.string_field(4)
    conflicts_with: List["PluginInfo"] = betterproto.message_field(5)


@dataclass
class PluginStateChangeRequest(betterproto.Message):
    plugin_id: int = betterproto.int32_field(1)
    enabled: bool = betterproto.bool_field(2)


@dataclass
class DeviceInfoRequest(betterproto.Message):
    """request info on a device"""

    plugin_id: int = betterproto.int32_field(1)


@dataclass
class PortInfo(betterproto.Message):
    port_id: int = betterproto.int32_field(1)
    priority_capability: int = betterproto.int32_field(2)
    description: str = betterproto.string_field(5)
    universe: int = betterproto.int32_field(3)
    active: bool = betterproto.bool_field(4)
    priority_mode: int = betterproto.int32_field(6)
    priority: int = betterproto.int32_field(7)
    supports_rdm: bool = betterproto.bool_field(8)


@dataclass
class DeviceInfo(betterproto.Message):
    device_alias: int = betterproto.int32_field(1)
    plugin_id: int = betterproto.int32_field(2)
    device_name: str = betterproto.string_field(3)
    input_port: List["PortInfo"] = betterproto.message_field(4)
    output_port: List["PortInfo"] = betterproto.message_field(5)
    device_id: str = betterproto.string_field(6)


@dataclass
class DeviceInfoReply(betterproto.Message):
    device: List["DeviceInfo"] = betterproto.message_field(1)


@dataclass
class DmxData(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    data: bytes = betterproto.bytes_field(2)
    priority: int = betterproto.int32_field(3)


@dataclass
class RegisterDmxRequest(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    action: "RegisterAction" = betterproto.enum_field(2)


@dataclass
class PatchPortRequest(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    device_alias: int = betterproto.int32_field(2)
    port_id: int = betterproto.int32_field(3)
    action: "PatchAction" = betterproto.enum_field(4)
    is_output: bool = betterproto.bool_field(5)


@dataclass
class UniverseNameRequest(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)


@dataclass
class MergeModeRequest(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    merge_mode: "MergeMode" = betterproto.enum_field(2)


@dataclass
class OptionalUniverseRequest(betterproto.Message):
    """request info about a universe"""

    universe: int = betterproto.int32_field(1)


@dataclass
class UniverseInfo(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    name: str = betterproto.string_field(2)
    merge_mode: "MergeMode" = betterproto.enum_field(3)
    input_port_count: int = betterproto.int32_field(4)
    output_port_count: int = betterproto.int32_field(5)
    rdm_devices: int = betterproto.int32_field(6)
    input_ports: List["PortInfo"] = betterproto.message_field(7)
    output_ports: List["PortInfo"] = betterproto.message_field(8)


@dataclass
class UniverseInfoReply(betterproto.Message):
    universe: List["UniverseInfo"] = betterproto.message_field(1)


@dataclass
class PortPriorityRequest(betterproto.Message):
    device_alias: int = betterproto.int32_field(1)
    is_output: bool = betterproto.bool_field(2)
    port_id: int = betterproto.int32_field(3)
    priority_mode: int = betterproto.int32_field(4)
    priority: int = betterproto.int32_field(5)


@dataclass
class DeviceConfigRequest(betterproto.Message):
    """a device config request"""

    device_alias: int = betterproto.int32_field(1)
    data: bytes = betterproto.bytes_field(2)


@dataclass
class DeviceConfigReply(betterproto.Message):
    data: bytes = betterproto.bytes_field(1)


@dataclass
class UID(betterproto.Message):
    """RDM Messages This represents a UID"""

    esta_id: int = betterproto.int32_field(1)
    device_id: float = betterproto.fixed32_field(2)


@dataclass
class UniverseRequest(betterproto.Message):
    """Request the UID list for a universe"""

    universe: int = betterproto.int32_field(1)


@dataclass
class DiscoveryRequest(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    full: bool = betterproto.bool_field(2)


@dataclass
class UIDListReply(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    uid: List["UID"] = betterproto.message_field(2)


@dataclass
class RDMRequestOverrideOptions(betterproto.Message):
    sub_start_code: int = betterproto.uint32_field(1)
    message_length: int = betterproto.uint32_field(2)
    message_count: int = betterproto.uint32_field(3)
    checksum: int = betterproto.uint32_field(4)


@dataclass
class RDMRequest(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    uid: "UID" = betterproto.message_field(2)
    sub_device: int = betterproto.int32_field(3)
    param_id: int = betterproto.int32_field(4)
    data: bytes = betterproto.bytes_field(5)
    is_set: bool = betterproto.bool_field(6)
    include_raw_response: bool = betterproto.bool_field(7)
    options: "RDMRequestOverrideOptions" = betterproto.message_field(8)


@dataclass
class RDMDiscoveryRequest(betterproto.Message):
    universe: int = betterproto.int32_field(1)
    uid: "UID" = betterproto.message_field(2)
    sub_device: int = betterproto.int32_field(3)
    param_id: int = betterproto.int32_field(4)
    data: bytes = betterproto.bytes_field(5)
    include_raw_response: bool = betterproto.bool_field(6)
    options: "RDMRequestOverrideOptions" = betterproto.message_field(8)


@dataclass
class RDMFrameTiming(betterproto.Message):
    response_delay: int = betterproto.int32_field(1)
    break_time: int = betterproto.int32_field(2)
    mark_time: int = betterproto.int32_field(3)
    data_time: int = betterproto.int32_field(4)


@dataclass
class RDMFrame(betterproto.Message):
    raw_response: bytes = betterproto.bytes_field(1)
    timing: "RDMFrameTiming" = betterproto.message_field(2)


@dataclass
class RDMResponse(betterproto.Message):
    response_code: "RDMResponseCode" = betterproto.enum_field(1)
    source_uid: "UID" = betterproto.message_field(9)
    dest_uid: "UID" = betterproto.message_field(10)
    transaction_number: int = betterproto.int32_field(11)
    # ACK, NACK or TIMER
    response_type: "RDMResponseType" = betterproto.enum_field(2)
    message_count: int = betterproto.uint32_field(3)
    sub_device: int = betterproto.uint32_field(7)
    command_class: "RDMCommandClass" = betterproto.enum_field(6)
    param_id: int = betterproto.uint32_field(5)
    data: bytes = betterproto.bytes_field(4)
    raw_response: List[bytes] = betterproto.bytes_field(8)
    raw_frame: List["RDMFrame"] = betterproto.message_field(12)


@dataclass
class TimeCode(betterproto.Message):
    hours: int = betterproto.uint32_field(1)
    minutes: int = betterproto.uint32_field(2)
    seconds: int = betterproto.uint32_field(3)
    frames: int = betterproto.uint32_field(4)
    type: "TimeCodeType" = betterproto.enum_field(5)


class OlaServerServiceStub(betterproto.ServiceStub):
    """RPCs handled by the OLA Server"""

    async def get_plugins(self) -> PluginListReply:
        request = PluginListRequest()

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetPlugins",
            request,
            PluginListReply,
        )

    async def reload_plugins(self) -> Ack:
        request = PluginReloadRequest()

        return await self._unary_unary(
            "/ola.proto.OlaServerService/ReloadPlugins",
            request,
            Ack,
        )

    async def get_plugin_description(
        self, *, plugin_id: int = 0
    ) -> PluginDescriptionReply:
        request = PluginDescriptionRequest()
        request.plugin_id = plugin_id

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetPluginDescription",
            request,
            PluginDescriptionReply,
        )

    async def get_plugin_state(self, *, plugin_id: int = 0) -> PluginStateReply:
        request = PluginStateRequest()
        request.plugin_id = plugin_id

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetPluginState",
            request,
            PluginStateReply,
        )

    async def get_device_info(self, *, plugin_id: int = 0) -> DeviceInfoReply:
        request = DeviceInfoRequest()
        request.plugin_id = plugin_id

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetDeviceInfo",
            request,
            DeviceInfoReply,
        )

    async def get_candidate_ports(self, *, universe: int = 0) -> DeviceInfoReply:
        request = OptionalUniverseRequest()
        request.universe = universe

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetCandidatePorts",
            request,
            DeviceInfoReply,
        )

    async def configure_device(
        self, *, device_alias: int = 0, data: bytes = b""
    ) -> DeviceConfigReply:
        request = DeviceConfigRequest()
        request.device_alias = device_alias
        request.data = data

        return await self._unary_unary(
            "/ola.proto.OlaServerService/ConfigureDevice",
            request,
            DeviceConfigReply,
        )

    async def set_plugin_state(
        self, *, plugin_id: int = 0, enabled: bool = False
    ) -> Ack:
        request = PluginStateChangeRequest()
        request.plugin_id = plugin_id
        request.enabled = enabled

        return await self._unary_unary(
            "/ola.proto.OlaServerService/SetPluginState",
            request,
            Ack,
        )

    async def set_port_priority(
        self,
        *,
        device_alias: int = 0,
        is_output: bool = False,
        port_id: int = 0,
        priority_mode: int = 0,
        priority: int = 0,
    ) -> Ack:
        request = PortPriorityRequest()
        request.device_alias = device_alias
        request.is_output = is_output
        request.port_id = port_id
        request.priority_mode = priority_mode
        request.priority = priority

        return await self._unary_unary(
            "/ola.proto.OlaServerService/SetPortPriority",
            request,
            Ack,
        )

    async def get_universe_info(self, *, universe: int = 0) -> UniverseInfoReply:
        request = OptionalUniverseRequest()
        request.universe = universe

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetUniverseInfo",
            request,
            UniverseInfoReply,
        )

    async def set_universe_name(self, *, universe: int = 0, name: str = "") -> Ack:
        request = UniverseNameRequest()
        request.universe = universe
        request.name = name

        return await self._unary_unary(
            "/ola.proto.OlaServerService/SetUniverseName",
            request,
            Ack,
        )

    async def set_merge_mode(
        self, *, universe: int = 0, merge_mode: "MergeMode" = 0
    ) -> Ack:
        request = MergeModeRequest()
        request.universe = universe
        request.merge_mode = merge_mode

        return await self._unary_unary(
            "/ola.proto.OlaServerService/SetMergeMode",
            request,
            Ack,
        )

    async def patch_port(
        self,
        *,
        universe: int = 0,
        device_alias: int = 0,
        port_id: int = 0,
        action: "PatchAction" = 0,
        is_output: bool = False,
    ) -> Ack:
        request = PatchPortRequest()
        request.universe = universe
        request.device_alias = device_alias
        request.port_id = port_id
        request.action = action
        request.is_output = is_output

        return await self._unary_unary(
            "/ola.proto.OlaServerService/PatchPort",
            request,
            Ack,
        )

    async def register_for_dmx(
        self, *, universe: int = 0, action: "RegisterAction" = 0
    ) -> Ack:
        request = RegisterDmxRequest()
        request.universe = universe
        request.action = action

        return await self._unary_unary(
            "/ola.proto.OlaServerService/RegisterForDmx",
            request,
            Ack,
        )

    async def update_dmx_data(
        self, *, universe: int = 0, data: bytes = b"", priority: int = 0
    ) -> Ack:
        request = DmxData()
        request.universe = universe
        request.data = data
        request.priority = priority

        return await self._unary_unary(
            "/ola.proto.OlaServerService/UpdateDmxData",
            request,
            Ack,
        )

    async def get_dmx(self, *, universe: int = 0) -> DmxData:
        request = UniverseRequest()
        request.universe = universe

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetDmx",
            request,
            DmxData,
        )

    async def get_u_i_ds(self, *, universe: int = 0) -> UIDListReply:
        request = UniverseRequest()
        request.universe = universe

        return await self._unary_unary(
            "/ola.proto.OlaServerService/GetUIDs",
            request,
            UIDListReply,
        )

    async def force_discovery(
        self, *, universe: int = 0, full: bool = False
    ) -> UIDListReply:
        request = DiscoveryRequest()
        request.universe = universe
        request.full = full

        return await self._unary_unary(
            "/ola.proto.OlaServerService/ForceDiscovery",
            request,
            UIDListReply,
        )

    async def set_source_u_i_d(self, *, esta_id: int = 0, device_id: float = 0) -> Ack:
        request = UID()
        request.esta_id = esta_id
        request.device_id = device_id

        return await self._unary_unary(
            "/ola.proto.OlaServerService/SetSourceUID",
            request,
            Ack,
        )

    async def r_d_m_command(
        self,
        *,
        universe: int = 0,
        uid: Optional["UID"] = None,
        sub_device: int = 0,
        param_id: int = 0,
        data: bytes = b"",
        is_set: bool = False,
        include_raw_response: bool = False,
        options: Optional["RDMRequestOverrideOptions"] = None,
    ) -> RDMResponse:
        request = RDMRequest()
        request.universe = universe
        if uid is not None:
            request.uid = uid
        request.sub_device = sub_device
        request.param_id = param_id
        request.data = data
        request.is_set = is_set
        request.include_raw_response = include_raw_response
        if options is not None:
            request.options = options

        return await self._unary_unary(
            "/ola.proto.OlaServerService/RDMCommand",
            request,
            RDMResponse,
        )

    async def r_d_m_discovery_command(
        self,
        *,
        universe: int = 0,
        uid: Optional["UID"] = None,
        sub_device: int = 0,
        param_id: int = 0,
        data: bytes = b"",
        include_raw_response: bool = False,
        options: Optional["RDMRequestOverrideOptions"] = None,
    ) -> RDMResponse:
        request = RDMDiscoveryRequest()
        request.universe = universe
        if uid is not None:
            request.uid = uid
        request.sub_device = sub_device
        request.param_id = param_id
        request.data = data
        request.include_raw_response = include_raw_response
        if options is not None:
            request.options = options

        return await self._unary_unary(
            "/ola.proto.OlaServerService/RDMDiscoveryCommand",
            request,
            RDMResponse,
        )

    async def stream_dmx_data(
        self, *, universe: int = 0, data: bytes = b"", priority: int = 0
    ) -> STREAMING_NO_RESPONSE:
        request = DmxData()
        request.universe = universe
        request.data = data
        request.priority = priority

        return await self._unary_unary(
            "/ola.proto.OlaServerService/StreamDmxData",
            request,
            STREAMING_NO_RESPONSE,
        )

    async def send_time_code(
        self,
        *,
        hours: int = 0,
        minutes: int = 0,
        seconds: int = 0,
        frames: int = 0,
        type: "TimeCodeType" = 0,
    ) -> Ack:
        """timecode"""

        request = TimeCode()
        request.hours = hours
        request.minutes = minutes
        request.seconds = seconds
        request.frames = frames
        request.type = type

        return await self._unary_unary(
            "/ola.proto.OlaServerService/SendTimeCode",
            request,
            Ack,
        )


class OlaClientServiceStub(betterproto.ServiceStub):
    """RPCs handled by the OLA Client"""

    async def update_dmx_data(
        self, *, universe: int = 0, data: bytes = b"", priority: int = 0
    ) -> Ack:
        request = DmxData()
        request.universe = universe
        request.data = data
        request.priority = priority

        return await self._unary_unary(
            "/ola.proto.OlaClientService/UpdateDmxData",
            request,
            Ack,
        )
